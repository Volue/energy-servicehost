/* Generated by Together */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using Powel.Icc.Common;	
using Powel.Icc.Data;
using Powel.Icc.Data.Entities;
using Powel.Icc.Data.Metering;
using Powel.Icc.Data.Entities.Metering;
using Powel.Icc.Services.Time;


namespace Powel.Icc.Metering {

/// <summary>
/// Summary description for the class.
/// </summary>

	public class MeteringOrderLogic
	{

		/// <summary>
		/// Fetches new ('validfrom' before given timestamp) metering orders that have been changed. Metering orders that have validFrom further ahead in time are omitted.
		/// </summary>
		/// <param name="beforeTime">Timestamp, limit for the latest possible time of new metering orders retrieved </param>
		/// <param name="connection"></param>
		public static MeteringOrder[] GetNewMeteringOrders(UtcTime beforeTime, IDbConnection connection)
		{
			ArrayList alOrders = new ArrayList();
			RegionalCalendar cal = IccConfiguration.Time.DatabaseCalendar;

			bool grouped = true; //true = get only one timeseries per measure point
			DataTable dtImpDefs = ImportExportData.GetChangedImportDefinitions(beforeTime, grouped, connection);
			
			int timsKey = -1;
			UtcTime fromTime;
			foreach( DataRow dr in dtImpDefs.Rows)
			{
				fromTime = cal.ToUtcTime((string) dr["fromtime"]);
				fromTime = cal.AddHours(fromTime, 1);
				timsKey = Util.GetInt32(dr, "tims_key");

			    MeteringOrder meteringOrder = new MeteringOrder();
				alOrders.Add(meteringOrder);

				MeasurePoint measurePoint = MeasurePointData.GetForTimeSeries(timsKey, fromTime, connection);
				if (measurePoint == null)
				{
					meteringOrder.SendStatus = MeteringOrder.SendingStatus.MISSING_MEASUREPOINT;
					meteringOrder.ImportDefinition = new ImportDefinition(timsKey, fromTime);
					continue;
				}
				else
				{
					meteringOrder.MeasurePoint = measurePoint;
				}

				int[] timeSeriesKeys = TimeSeriesData.GetKeysForMeasurePoint(measurePoint.Id, fromTime, connection);

				Hashtable registerImportDefinitions = new Hashtable();

				bool foundImportDefinitions = false;
				bool foundRegisters = false;

				foreach(int timeSeriesKey in timeSeriesKeys)
				{
					ImportDefinition impDef = ImportExportData.FetchImportDefinition(timeSeriesKey, fromTime, TsProtocol.PDXML, connection);

					if (impDef != null)
					{
						foundImportDefinitions = true;
						Register register = RegisterLogic.GetForTimeSeries(impDef.TsCode, measurePoint, fromTime, connection);

						if (register != null)
						{
							foundRegisters = true;
							registerImportDefinitions.Add(register, impDef);
						}
					}
				}

				if (!foundImportDefinitions)
					meteringOrder.SendStatus = MeteringOrder.SendingStatus.MISSING_IMPDEF;
				else if (!foundRegisters)
					meteringOrder.SendStatus = MeteringOrder.SendingStatus.MISSING_REGISTER;
				else if (registerImportDefinitions.Count == 0)
					meteringOrder.SendStatus = MeteringOrder.SendingStatus.FAILED;
				else
					meteringOrder.RegisterImportDefinitions = registerImportDefinitions;
			}

			return (MeteringOrder[])alOrders.ToArray(typeof(MeteringOrder));
        }
		
		/// <summary>
		/// Deletes metering orders (that have been processed) by calling ImportExportData.DeleteChangedImportDefs
		/// </summary>
		/// <param name="meteringOrders">Metering orders</param>
		/// <param name="beforeTime">limit timestamp, usually the same as used during GetNewMeteringOrders</param>
        /// <param name="connection"></param>
        public static void DeleteNewMeteringOrders(MeteringOrder[] meteringOrders, UtcTime beforeTime, IDbConnection connection)
		{
			int n = 0;
			foreach (MeteringOrder mo in meteringOrders)
			{
				if(mo.RegisterImportDefinitions != null)
				{
					n += mo.RegisterImportDefinitions.Values.Count;
				}
			}

			ImportDefinition[] impDefs = new ImportDefinition[n];
			
			int i = 0;
			foreach(MeteringOrder mo in meteringOrders)
			{
				if (mo.RegisterImportDefinitions != null)
				{
					foreach (ImportDefinition imp in mo.RegisterImportDefinitions.Values)
					{
						impDefs[i++] = imp;
					}
				}
			}
			ImportExportData.DeleteChangedImportDefinitions(impDefs, beforeTime, connection);
        }

        public static void SaveOnDemandMeteringOrder(string measurePointID, Agreement.DebitingType debitingType, UtcTime dateOfTransfer, UtcTime dataFromDate, UtcTime dataToDate, RegistrationReason reason, string connectionString)
		{
            using (IDbConnection connection = Util.OpenConnection(connectionString))
			{
				using (IDbTransaction transaction = Util.OpenTransaction(connection))
				{
					RegionalCalendar cal = RegionalCalendar.UtcCalendar;

					MeasurePoint measurePoint;
					List<MeasurePoint> measurePoints = MeasurePointData.GetByID(measurePointID, dataFromDate, connection);
					if( measurePoints.Count < 1)
						throw new IccException(10004, measurePointID, dateOfTransfer.ToString()); //MeasurePoint not found
					if( measurePoints.Count > 1)
						throw new IccException(10005, measurePointID, dateOfTransfer.ToString()); //Ambiguous measure points
					measurePoint = measurePoints[0];
					TimePeriod orderPeriod = new TimePeriod(dataFromDate, dataToDate);

					Agreement[] agreements = AgreementData.GetForMeasurePoint(measurePoint, orderPeriod, connection);
					if( agreements == null || agreements.Length == 0 )
						throw new IccException(10014, measurePointID, orderPeriod.From.ToString(), orderPeriod.Until.ToString());

					foreach(Agreement agreement in agreements)
					{
						TimePeriod partOrderPeriod = orderPeriod.Intersection(new TimePeriod(agreement.ValidFromDate, agreement.ValidToDate));

						ArrayList timsKeys = GetTimeSeries(measurePoint, debitingType, partOrderPeriod.From, connection);
					
						if(timsKeys.Count < 1)
							throw new IccException(10011, new string[]{measurePointID, debitingType.ToString(), dataFromDate.ToString(), dataToDate.ToString()});

						foreach(int timsKey in timsKeys)
						{
							WayOfRegistrationType wor = debitingType == Agreement.DebitingType.S?WayOfRegistrationType.ACCUMULATIVE:WayOfRegistrationType.DIFFERENTIAL;
							MeteringOrderData.SaveOnDemandMeteringOrder(timsKey, agreement.ReceiverId, wor, dateOfTransfer, partOrderPeriod.From, partOrderPeriod.Until, reason, connection);
						}

						if( debitingType == Agreement.DebitingType.S)
							MeteringOrderData.SaveAccumulativeExportOrder((int[])timsKeys.ToArray(typeof(int)), agreement.ReceiverId, partOrderPeriod.From, IccConfiguration.Metering.AccumulativeMeteringOrderOffset, IccConfiguration.Metering.AccumulativeMeteringOrderOffset,TsExpDefInterval.ONCE, dataFromDate, cal.AddHours(dataFromDate, IccConfiguration.Metering.AccumulativeMeteringOrderDuration), reason, connection);
					}

					transaction.Commit();
				}
			}
		}

        private static ArrayList GetTimeSeries(MeasurePoint measurePoint, Agreement.DebitingType debitingType, UtcTime validAt, IDbConnection connection)
		{
			ArrayList timsKeys = new ArrayList();
			Hashtable registers;
			switch(debitingType)
			{
				case Agreement.DebitingType.S:
					registers = AgreementLogic.GetRegisters(measurePoint, WayOfRegistrationType.ACCUMULATIVE, validAt, connection);
					break;
				case Agreement.DebitingType.T:
					registers = AgreementLogic.GetRegisters(measurePoint, WayOfRegistrationType.DIFFERENTIAL, validAt, connection);
					break;
				default:
					registers = AgreementLogic.GetRegisters(measurePoint, validAt, connection);
					break;
			}

			//Exclude registers without remote metering
			int timsKey = Int32.MinValue;
			foreach( Register register in registers.Keys)
			{
				if( register.RemoteMetering == RemoteMeteringType.YES)
				{
					timsKey = AgreementLogic.GetTimeSeries(measurePoint, register, validAt, connection);
					timsKeys.Add(timsKey);
				}
			}

			return timsKeys;
        }

        public static MeteringOrderOnDemandCollection[] GetNewOnDemandMeteringOrders(IDbConnection connection)
        {
        	return (MeteringOrderOnDemandCollection[]) MeteringOrderData.GetNewOnDemandMeteringOrders(connection).ToArray(typeof(MeteringOrderOnDemandCollection));
        }

		public static MeteringOrderOnDemandCollection[] GetDifferentialMeteringOrders(UtcTime before, IDbConnection connection)
		{
			return (MeteringOrderOnDemandCollection[]) MeteringOrderData.GetDifferentialOnDemandMeteringOrders(before, connection).ToArray(typeof(MeteringOrderOnDemandCollection));
		}

		public static MeteringOrderOnDemandCollection[] SplitOnDemandMeteringOrders(MeteringOrderOnDemandCollection[] MOODCollections, IDbConnection connection)
		{
			ArrayList onDemandMeteringOrderCollections = new ArrayList(MOODCollections);
			ArrayList alMoodColAdd = new ArrayList();			

			foreach(MeteringOrderOnDemandCollection moodCol in onDemandMeteringOrderCollections)
			{
				foreach(MeteringOrderOnDemand mood in moodCol.MeteringOrdersOnDemand)
				{
					Register register;
					MeasurePoint measurePoint = MeasurePointData.GetForTimeSeries(mood.TimsKey, moodCol.DataFromTime, connection);
					if( measurePoint == null)
					{
						mood.SendStatus = MeteringOrderOnDemand.SendingStatus.MISSING_MEASUREPOINT;
						continue;
					}
					ImportDefinition[] impDefs = ImportExportData.FetchImportDefinitions(mood.TimsKey, moodCol.DataFromTime, moodCol.DataToTime, TsProtocol.PDXML, connection);
					if( impDefs == null)
					{
						mood.SendStatus = MeteringOrderOnDemand.SendingStatus.MISSING_IMPDEF;
						continue;
					}
					else if( impDefs.Length == 1) //USUALLY
					{
						register = RegisterLogic.GetForTimeSeries(impDefs[0].TsCode, measurePoint, moodCol.DataFromTime, connection);
						if( register != null)
						{
							mood.MeasurePoint = measurePoint;
							mood.ImportDefinition = impDefs[0];
							mood.Register = register;
						}
						else
						{
							mood.SendStatus = MeteringOrderOnDemand.SendingStatus.MISSING_REGISTER;
							continue;
						}
					}
					else if(impDefs.Length > 1)
					{
						mood.SendStatus = MeteringOrderOnDemand.SendingStatus.SPLITTED;
						TimePeriod tpData = new TimePeriod(moodCol.DataFromTime, moodCol.DataToTime);
						foreach( ImportDefinition impDef in impDefs)
						{
							TimePeriod tpNew = impDef.ValidPeriod.Intersection(tpData);
							MeteringOrderOnDemandCollection col = new MeteringOrderOnDemandCollection(moodCol.DateOfTransfer, tpNew.From, tpNew.Until, moodCol.Reason);
							register = RegisterLogic.GetForTimeSeries(impDef.TsCode, measurePoint, moodCol.DataFromTime, connection);
							if( register == null)
							{
								col.AddMeteringOrderOnDemand(new MeteringOrderOnDemand(measurePoint, impDef, null, mood, MeteringOrderOnDemand.SendingStatus.SPLIT_MISSING_REGISTER));
								continue;
							}
							col.AddMeteringOrderOnDemand(new MeteringOrderOnDemand(measurePoint, impDef, register, mood, MeteringOrderOnDemand.SendingStatus.SPLIT));
							alMoodColAdd.Add(col);
						}
					}
				}				
			}
			foreach( MeteringOrderOnDemandCollection moodCol in alMoodColAdd)
				onDemandMeteringOrderCollections.Add(moodCol);

			return (MeteringOrderOnDemandCollection[]) onDemandMeteringOrderCollections.ToArray(typeof(MeteringOrderOnDemandCollection));
		}

		public static void MarkSentOnDemandMeteringOrders(MeteringOrderOnDemandCollection[] onDemandMeteringOrderCollections, IDbConnection connection)
		{
			//iterate all orders and mark accordingly
			ArrayList alOK = new ArrayList();
			ArrayList alFailed = new ArrayList();
			foreach(MeteringOrderOnDemandCollection moodCol in onDemandMeteringOrderCollections)
			{
				foreach(MeteringOrderOnDemand mood in moodCol.MeteringOrdersOnDemand)
				{
					if( mood.SendStatus == MeteringOrder.SendingStatus.OK)
						alOK.Add(mood);
					else switch (mood.SendStatus)
					{
					    case MeteringOrder.SendingStatus.SPLIT:
					        if( !alOK.Contains(mood.Original))
					            alOK.Add(mood.Original);
					        break;
					    case MeteringOrder.SendingStatus.SPLIT_MISSING_REGISTER:
					        if( !alFailed.Contains(mood.Original))
					            alFailed.Add(mood.Original);
					        break;
					    default:
					        alFailed.Add(mood);
					        break;
					}
				}
			}

			MeteringOrderData.MarkNewOnDemandMeteringOrders(new MeteringOrderOnDemandCollection(UtcTime.Null, UtcTime.Null, UtcTime.Null, RegistrationReason.UNDEFINED, alOK), MeteringOrderOnDemand.Status.FORWARDED_MSS, connection);
			MeteringOrderData.MarkNewOnDemandMeteringOrders(new MeteringOrderOnDemandCollection(UtcTime.Null, UtcTime.Null, UtcTime.Null, RegistrationReason.UNDEFINED, alFailed), MeteringOrderOnDemand.Status.FORWARD_MSS_FAILED, connection);
		}

		public static void MarkExportedOnDemandMeteringOrders(MeteringOrderOnDemandCollection[] onDemandMeteringOrderCollections, IDbConnection connection)
		{
			//iterate all orders and mark accordingly
			ArrayList alOK = new ArrayList();
			ArrayList alFailed = new ArrayList();
			foreach(MeteringOrderOnDemandCollection moodCol in onDemandMeteringOrderCollections)
			{
				foreach(MeteringOrderOnDemand mood in moodCol.MeteringOrdersOnDemand)
				{
					if( mood.ExportStatus == MeteringOrderOnDemand.ExpStatus.EXPORTED_OK)
						alOK.Add(mood);
					else if(mood.ExportStatus == MeteringOrderOnDemand.ExpStatus.EXPORT_FAILED)
						alFailed.Add(mood);
				}
			}

			MeteringOrderData.MarkNewOnDemandMeteringOrders(new MeteringOrderOnDemandCollection(UtcTime.Null, UtcTime.Null, UtcTime.Null, RegistrationReason.UNDEFINED, alOK), MeteringOrderOnDemand.Status.EXPORTED_GS2, connection);
			MeteringOrderData.MarkNewOnDemandMeteringOrders(new MeteringOrderOnDemandCollection(UtcTime.Null, UtcTime.Null, UtcTime.Null, RegistrationReason.UNDEFINED, alFailed), MeteringOrderOnDemand.Status.EXPORT_GS2_FAILED, connection);
		}

		public static void SaveCyclicAccumulativeMeteringOrder(int timsKey, string receiver, UtcTime utcTime, Agreement.Frequency exportMethod, UtcTime validFrom, UtcTime validTo, RegistrationReason reason, IDbConnection connection) //, bool doCleanup)
		{
			RegionalCalendar cal = IccConfiguration.Time.DatabaseCalendar;
			UtcTime timestamp;
			TsExpDefInterval interval;
			int hOffsetBackward = IccConfiguration.Metering.AccumulativeMeteringOrderOffset;
			int hOffsetForward = hOffsetBackward;
			switch(exportMethod)
			{
				case Agreement.Frequency.DAILY:
					interval = TsExpDefInterval.ONCE_A_DAY;
					timestamp = cal.ToUtcTime(IccConfiguration.Metering.AccumulativeMeteringOrderIntervalStartTime_Daily);
					break;
				case Agreement.Frequency.WEEKLY:
					interval = TsExpDefInterval.ONCE_A_WEEK;
					timestamp = cal.ToUtcTime(IccConfiguration.Metering.AccumulativeMeteringOrderIntervalStartTime_Weekly);
					break;
				case Agreement.Frequency.MONTHLY:
					interval = TsExpDefInterval.ONCE_A_MONTH;
					timestamp = cal.ToUtcTime(IccConfiguration.Metering.AccumulativeMeteringOrderIntervalStartTime_Monthly);
					break;
				case Agreement.Frequency.YEARLY:
					interval = TsExpDefInterval.ONCE_A_YEAR;
					timestamp = cal.ToUtcTime(IccConfiguration.Metering.AccumulativeMeteringOrderIntervalStartTime_Yearly);
					break;
				case Agreement.Frequency.NEVER: //Fix for 7.4.19
					interval = TsExpDefInterval.NEVER;
					timestamp = cal.ToUtcTime(DateTime.Now.AddYears(30));
					break;
				default:
					throw new ApplicationException("Frequency " + exportMethod + " not supported for cyclic accumulative export order");
			}

			if (utcTime != UtcTime.Null) timestamp = utcTime;
			if (validTo == UtcTime.Null) validTo = UtcTime.MaxValue;

			MeteringOrderData.SaveAccumulativeExportOrder(new []{timsKey}, receiver, timestamp, hOffsetBackward, hOffsetForward, interval, validFrom, validTo, reason, connection);
		}
    }
}
